# 设计模式

### 工厂模式

**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**主要解决：**接口选择的问题。

**何时使用：**我们明确地计划不同条件下创建不同实例时。

**如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。

**关键代码：**创建过程在其子类执行。

一般用于创建复杂对象，如果是简单对象没必要增加麻烦。



### 抽象工厂

和工厂模式相比更加抽象，建立了一个***“联合工厂”***，由联合工厂实例化具体工厂，再执行工厂的细节。



### 单例模式

保证一个类只有**一个实例**，并且提供了外界访问该实例的方式。

**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决：**一个全局使用的类频繁地创建与销毁。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码：**构造函数是私有的。

**实现方法**：

- **懒汉式、线程不安全**
  - 定义一个静态的函数来获取实例，当实例不存在时创建。
- **懒汉、线程安全**
  - 和上述实现方法一样，但是加锁 synchronized 保证单例。但是加锁会影响效率。
- **饿汉式**
  - 添加该类**静态成员变量**作为唯一实例（private static Singleton instance = new Singleton();  ）
  - 类加载时即初始化，浪费内存
- **双检锁/双重校验锁（DCL，即 double-checked locking）**

```Java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}
```

- **登记式/静态内部类**

```
public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}
```





### 命令模式

请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。相当于解耦了输入和操作对象之间的关系，把命令独立了开来变成对应的类。



###  建造者模式

使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

例如一份麦当劳特价套餐一般包含汉堡、薯条、饮料，但这三者都有多种选择，这里就可以用建造者模式构建套餐。当然这个例子的组件之间关系还是算松散，如果要制造汽车，必然是先建好框架才能安装轮子，这里框架和轮子虽然能够有多个选择，但是创建顺序则是固定的。建造者模式可以交方便地控制这些顺序。



### 适配器模式

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。

说白了就是转换插座，因为原本类没有提供某个接口，不想直接修改这个类的话，就写一个中间类实现利用该类原有的方法来实现这个接口。所以适配器模式的实现方法有两种，一种是新类继承目标类同时实现新的接口，另一种是新类包含目标类成员变量，通过成员变量来实现接口。



### 享元模式

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

例如你要渲染一片森林，绝大部分的树都是基于一个模型，那样可以仅仅将树的模型传入一次gpu重复使用，而不是每渲染一棵树就传入一次。这个模式某些情况下需要硬件支持，就如刚刚的例子。



### 观察者模式

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

抽象出观察者接口，然后让观察者实现接口，而被观察者维护一个观察者列表，每次操作都会把信息告诉观察者。

例如在游戏中有一个特定行为达到次数的成就系统，可以将成就系统变成观察者，实现行为的类作为被观察者维护观察者列表，每次都通知所有观察者。
