# 设计模式

### 工厂模式

**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**主要解决：**接口选择的问题。

**何时使用：**我们明确地计划不同条件下创建不同实例时。

**如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。

**关键代码：**创建过程在其子类执行。

一般用于创建复杂对象，如果是简单对象没必要增加麻烦。



### 抽象工厂

和工厂模式相比更加抽象，建立了一个***“联合工厂”***，由联合工厂实例化具体工厂，再执行工厂的细节。



### 单例模式

保证一个类只有**一个实例**，并且提供了外界访问该实例的方式。

**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决：**一个全局使用的类频繁地创建与销毁。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码：**构造函数是私有的。

**实现方法**：

- **懒汉式、线程不安全**
  - 定义一个静态的函数来获取实例，当实例不存在时创建。
- **懒汉、线程安全**
  - 和上述实现方法一样，但是加锁 synchronized 保证单例。但是加锁会影响效率。
- **饿汉式**
  - 添加该类**静态成员变量**作为唯一实例（private static Singleton instance = new Singleton();  ）
  - 类加载时即初始化，浪费内存
- **双检锁/双重校验锁（DCL，即 double-checked locking）**

```Java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}
```

- **登记式/静态内部类**

```
public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}
```





### 命令模式

请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。