# C++ 面试遇到的问题

### 1.创建空类的时候编译器会为空类生成些什么

- **缺省构造函数**，应该就是默认构造函数，不带参数的那种
- **拷贝构造函数**，这是一种特殊的构造函数，参数是该类型的引用，用来将引用的对象复制给新的实例。这里涉及到**深复制**与**浅复制**的问题，默认生成的是**浅复制**的，即将类型包含的所有成员变量复制到新实例里面。这将会构成问题，因为浅复制不会更改静态成员变量，也不会new新的内存空间。
- **析构函数**
- **赋值运算符**，就是=
- **带const的与不带const的取址运算符**，即&



### 2.有3个类 A B C，B继承A、包含C类型的成员变量，创建B实例的时候调用构造函数的顺序是？

顺序是A C B。

创建实例时**构造函数**的调用顺序是：

- **虚拟基类**的构造函数（virtual public xxx）
- **非虚拟基类**的构造函数
- **成员变量**的构造函数
- **本身**的构造函数

每一种都是按声明时的顺序。

析构则是发过来，结合栈来理解。

引用：https://blog.csdn.net/udahci/article/details/93463468


### 3.虚函数

虚函数是用来实现**多态**的方法，即调用方法的行为取决于调用方法的对象。需要实现多态的基类函数前加virtual来声明虚函数，这样基类指针指向的实例就会按照实际类型执行该函数。

具体实现是编译器在有虚函数的类的成员变量前隐式创建一张**虚函数**表，里面存储着指向虚函数的地址，之后的所有子类都会继承这张表。如果子类重写了其中的函数，则虚函数列表了面对应的位置就会改为子类的函数。

**虚析构函数**是必须的，因为析构时需要按照子类的析构函数析构而不是父类的析构函数！



### 4. 右值引用

**左值**是指表达式结束后依然存在的持久化对象，**右值**是指表达式结束时就不再存在的临时对象。

区别就是&能够作用于左值，例如

```
int a = 10; 
int& refA = a; 
int& b= a+1;//error a+1是右值
```

这样refA相当于a的别名，修改refA相当于修改a

而c++11新增右值引用&&

```
int &&a=1;
int &&b=a;//error a是左值
```

但是有个奇葩

```
const int & a=1;
```

这一句不会报错

可以实现移动语义，考虑以下代码

```c++
vector<string> allcaps(const vector<string> & in){
    vector<string> temp(in);
    retrun temp;
}

int main(){
    vector<string> a;
    vector<string> b(a);
    vector<string> c(allcaps(a));
}
```

b会调用复制构造函数，把a的全部值复制到b，这很好理解，但c呢？，c需要执行两次复制构造函数，一次是temp的，一次是c的。这似乎很没有效率，特别是数组大小很大的时候。换个思路，既然temp是一个临时变量，一旦执行完函数就要作为左值销毁了，那要是c能够直接“占有”temp的内容，那不就只用复制一次了吗？这个就是移动语义。实际上编译器优化时确实会这么干，但是我们并不确定编译器会不会优化每一个这样的地方，因此我们需要自己控制。于是c++11就添加了右值引用。



### 5.重载运算符++

```c++
class A{
public:
	int a;
	A& operate++(){
		a++;
		return this;
	}
	A operate++(int){
		A temp(a);
		a++;
		return temp;
	}
}
```

